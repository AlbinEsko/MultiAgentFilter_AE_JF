# Multi-agent based settlement generator for minecraft
This repository holds the code created for my and [Johan](https://github.com/master-johan)'s batchelors thesis at Malmö University and is also an entry to the [GDMC](https://gendesignmc.engineering.nyu.edu/) competition for 2021.
This generator was creted for the McEdit Unified framework. To use it the repo should be exctracted to a directory then that directory is placed in the stock-filter directory. Afterwards the filter is available for use in the McEdit client. The current implementation by 2021-07-13 can at most handle a 256x256 area and takes aproximately 10 minutes to execute on that sized area.
## Generator Description
The core concept is a multi-agent system where each agent is responsible for individual jobs like expanding the roads or furnishing the building interiors. This system is based on previous multi agent city generators like Lechner, Thomas, Ben Watson, and Uri Wilensky. "Procedural city modeling." In 1st Midwestern Graphics Conference. 2003. The system utilizes stages which are denoted by the folowing headers.
### Information Gathering
The selected box within the Minecraft level is scanned and a heightmap and liquidmap is created. The heightmap is created by scanning each position in the y axis from top to bottom for each position in the x and z axis, and the position of the first ground block encountered determines the value in the height map for that position. Concurrently if the encountered block is any form of liquid that gets noted in the liquidmap. The heightmap is then used to create a weighted graph where the nodes are each of the positions from the heightmap and the weight is the difference in height between. The definition for a ground block is if it is naturally occuring on the surface and is solid and not wood or leaves. The definition for a liquid block is if it is lava or water.
#### Select Start Position
The first requirement for a settlement is selecting a starting position. This is done by utilizing the graph to conduct several depth-first searches (DFS) with a restriction on the height difference to detect if an area is on a similar level. The restriction is that a tile must have a height value which is within a small differential of the average height of the existing region. This search then outputs multiple regions which denote connected areas of similar height. Finally the starting location is set by using a random tiles position in the largest region. This is done to ensure the settlement has the maximum possible guaranteed area to expand.
### Road Generation
The road generation for the settlement is done using a multi agent system which consists of all the agents and a central data structure. The way it is implemented it guaranties complete traversability and connectivity of the road network. The central data structure for the road generation is the road system, not to be confused with the road network which is the actual roads visible in the game world. The road system stores all necessary tile data. It also contains most functions which are used to modify the game world through the addition, removal or swapping of blocks. The graph is a weighted digraph where the weight in the edges is the Manhattan distance (1 for non-diagonals and 2 for diagonals) added to the absolute value of the height difference between the adjacent tiles. The nodes contain the data for each tile in the grid. The data contains index and coordinates of the tile, its height, liquid and road value and if it's part of an existing plot, the tiles connection to other nodes, the tiles connection within the road system.
#### Extendor Agents
The Extendor Agents extend the road network by performing random walks through the terrain, note that this walk is only constrained to the initial selection’s bounds and does not account for terrain or liquids, and sampling their positions after every step to check if they are out of range of the road network. This is detected by comparing the road value in the node which corresponds with the position of the agent. When they find a position which is not serviced by the road network the agent uses a version of dijkstra's algorithm to find the closest piece of road and then suggest the found path to the road system for evaluation of the new road’s suitability. The edges in the graph are set up to not connect to any liquids in the graph and consequently prevents any path through liquids. Additionally, if the agent currently is in a liquid no path is found and the evaluation is aborted. If a valid path is found it is evaluated on two conditions, the first is the total weight of the new road. The weight should be less than the Manhattan distance multiplied by some value (4) between the start and end points of the suggestion to be acceptable. The other condition is a limit that any individual weight along the suggested path does not exceed 2, which prevents the road from rising in too large steps which would prevent accessibility for a minecraft player which can only jump 1 block.
#### Connector agents
The Connector agents increase the level of connection in the roads. This is done by traversing the existing roads and every step samples a random line from it. The line is drawn by Digital Differential Algorithm to  If that line intersects a road the agent evaluates the distance to the intersected point through the existing road system. This is done with dijkstra's algorithm using the connections on the roads. Then the distance is compared to the euclidean distance between the agent position and the intersection point and if the distance exceeds the euclidean distance multiplied with some value (3,5) the agent suggests a direct connection between the two points. This suggestion is put through the same evaluation conditions as the ones by the extendor agents.
### Plot Generation
Plot generation is also done with agents using a random walk. These roam within the range of the road system and at every step evaluate if they are standing on a road or on an already plotted area. If that's the case they move ahead otherwise they evaluate if a plot can be created there. This evaluation begins by finding the closest road by following the surrounding tiles’s road values until it reaches the road. Then it uses that position to inflate a plot with the use of a bounded depth-first search. The bounds are defined as the sides of a rectangle and are constrained to only span a certain size (12 tiles) in the x and y axis. This outputs a list of tiles which are sorted and placed in a 2D array which shows the shape of the plot. The final step is to find the largest rectangle in the collection of tiles; this is what the building generator uses to create the houses. This is done by iterating through each tile in the plot and alternatingly expanding a rectangle to the right and down until no expansion can be done in either direction because it would incorporate a tile which is not part of the plot. Through the iteration the dimensions of the largest found rectangle is saved and when it is finished the largest possible rectangle is found.
### Building Generation
The building generation iterates through the list of plots generated in the previous stage. The generation uses a process with a few random elements to change up its appearance. The process starts with creating a module for the building containing its bounding box i.e. its position in the world and size of the box. There is a chance that the building will be a two storey building, if that is the case an additional module will be created on top of the first one. The module serves as a base for creating floor, walls and roof depending on how many floors the building has. An 1d array is made as an abstraction for each wall. A door is placed on the wall which corresponds to the direction to the road that is passed from the plot generation, either north, south, east or west. Windows are then placed in a random fashion in these arrays.
Each module gets their own floorplan, consisting of a 2d array where the size is based on the modules x and y size. Each wall array created before is converted to the floorplan array. If the building has two storeys an appropriate stair is selected and included in the plan. The available stairs are made up of 8 pre-defined variants. Variants are stairs placed in each of the four corners that make up the building as well as which direction it is facing, clockwise or counter-clockwise. 
To place furniture in the building an agent is placed in the array. The starting position for the agent is the first step into the building from the entrance door. The agent traverses the array in an clockwise fashion on free positions. The agent then logs positions of possible placements of furniture. After completing a loop of the floorplan the agent is finished with that floorplan and continues to the other level if present. On the second level the agent acts as before but in addition it also places fences around the opening in the ground that gets made to accommodate the stairs leading up the the second level. 
Once all floors are traversed the list of possible placements get iterated through and assigned a randomly chosen furniture. To not overpopulate the building with furniture a limit on how many pieces of furniture are allowed per floor based on the building's size.
